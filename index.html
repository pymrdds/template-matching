<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°ï¼ˆç”»åƒã«ãƒãƒƒãƒç®‡æ‰€è¡¨ç¤ºï¼‰</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    pre { background: #f0f0f0; padding: 10px; white-space: pre-wrap; }
    img { max-width: 100%; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°ï¼ˆç”»åƒè¡¨ç¤ºä»˜ãï¼‰</h1>

  <label for="threshold">é–¾å€¤ (0ã€œ1):</label>
  <input type="number" id="threshold" min="0" max="1" step="0.01" value="0.95"><br><br>

  <label for="templateInput">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒ (.png):</label>
  <input type="file" id="templateInput" accept="image/png"><br><br>

  <label for="imageInput">å¯¾è±¡ç”»åƒ (.png, .jpg, .jpeg):</label>
  <input type="file" id="imageInput" accept="image/*"><br><br>

  <button onclick="runMatching()">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>

  <h2>çµæœãƒ­ã‚°:</h2>
  <pre id="output">ã“ã“ã«ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</pre>

  <h2>ãƒãƒƒãƒçµæœç”»åƒ:</h2>
  <img id="resultImage" src="" alt="ãƒãƒƒãƒçµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™">

  <script>
    let pyodide = null;

    async function loadPyodideAndPackages() {
      pyodide = await loadPyodide();
      await pyodide.loadPackage(["opencv-python", "numpy"]);
    }

    loadPyodideAndPackages();

    async function runMatching() {
      const threshold = parseFloat(document.getElementById("threshold").value);
      const templateInput = document.getElementById("templateInput");
      const imageInput = document.getElementById("imageInput");
      const outputEl = document.getElementById("output");
      const imgEl = document.getElementById("resultImage");

      if (templateInput.files.length === 0 || imageInput.files.length === 0) {
        outputEl.textContent = "â— ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã¨å¯¾è±¡ç”»åƒã‚’ä¸¡æ–¹é¸æŠã—ã¦ãã ã•ã„ã€‚";
        imgEl.src = "";
        return;
      }

      if (isNaN(threshold) || threshold < 0 || threshold > 1) {
        outputEl.textContent = "â— é–¾å€¤ã¯ 0ã€œ1 ã®é–“ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
        imgEl.src = "";
        return;
      }

      const templateName = "template.png"; // å›ºå®š
      const imageFile = imageInput.files[0];
      const imageExt = imageFile.name.split('.').pop().toLowerCase();
      const imageName = "uploaded." + imageExt;

      const templateBytes = new Uint8Array(await templateInput.files[0].arrayBuffer());
      const imageBytes = new Uint8Array(await imageFile.arrayBuffer());
      pyodide.FS.writeFile(templateName, templateBytes);
      pyodide.FS.writeFile(imageName, imageBytes);

      const pythonCode = `
import cv2
import numpy as np
import base64

log = []
try:
    log.append("ğŸ”¹ template èª­ã¿è¾¼ã¿ä¸­...")
    template = cv2.imread("${templateName}", 0)
    if template is None:
        raise Exception("ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—")

    log.append("ğŸ”¹ å¯¾è±¡ç”»åƒ èª­ã¿è¾¼ã¿ä¸­...")
    img_color = cv2.imread("${imageName}")  # ã‚«ãƒ©ãƒ¼ã§èª­ã¿è¾¼ã‚€
    img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

    log.append("ğŸ”¹ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°å®Ÿè¡Œä¸­...")
    res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)
    log.append("ğŸ”¹ é–¾å€¤ ${threshold} ä»¥ä¸Šã‚’æŠ½å‡ºä¸­...")
    loc = np.where(res >= ${threshold})
    result = list(zip(*loc[::-1]))

    # éæœ€å¤§æŠ‘åˆ¶ (Non-Maximum Suppression) ã®å‡¦ç†
    min_distance = 10  # è¿‘ãã®ãƒãƒƒãƒã‚’ç„¡è¦–ã™ã‚‹è·é›¢ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
    final_result = []

    for pt in result:
        add = True
        for other_pt in final_result:
            dist = np.linalg.norm(np.array(pt) - np.array(other_pt))  # è·é›¢ã‚’è¨ˆç®—
            if dist < min_distance:  # è¿‘ã™ãã‚‹å ´åˆã¯è¿½åŠ ã—ãªã„
                add = False
                break
        if add:
            final_result.append(pt)

    # Xåº§æ¨™ã®å°ã•ã„é †ã«ã‚½ãƒ¼ãƒˆ
    final_result_sorted = sorted(final_result, key=lambda x: x[0])

    if final_result_sorted:
        log.append("âœ… ãƒãƒƒãƒç®‡æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ:")
        if len(final_result_sorted) > 5:  # 5å€‹ä»¥ä¸Šã®ãƒãƒƒãƒãŒã‚ã‚‹å ´åˆã€è­¦å‘Šã‚’è¿½åŠ 
            log.append("âš ï¸ ãƒãƒƒãƒç®‡æ‰€ãŒå¤šã™ãã¾ã™ã€‚é–¾å€¤ã‚’èª¿æ•´ã™ã‚‹ã‹ã€ç¯„å›²ã‚’ç‹­ã‚ã¦ãã ã•ã„ã€‚")
        h, w = template.shape
        for pt in final_result_sorted:
            log.append(f"X: {pt[0]}, Y: {pt[1]}")
            cv2.rectangle(img_color, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)
            cv2.circle(img_color, (pt[0] + w // 2, pt[1] + h // 2), 10, (0, 255, 0), 2)
    else:
        log.append("âš ï¸ ãƒãƒƒãƒãªã—")

    # çµæœç”»åƒã‚’ä¿å­˜
    cv2.imwrite("result.png", img_color)

    # base64ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦JavaScriptã«è¿”ã™
    with open("result.png", "rb") as f:
        img_bytes = f.read()
    img_base64 = base64.b64encode(img_bytes).decode("utf-8")

except Exception as e:
    log.append("âŒ ã‚¨ãƒ©ãƒ¼: " + str(e))
    img_base64 = ""

"\\n".join(log) + "\\n__SPLIT__\\n" + img_base64
`;

      try {
        const result = await pyodide.runPythonAsync(pythonCode);
        const [logText, imgBase64] = result.split("__SPLIT__");
        outputEl.textContent = logText;
        if (imgBase64) {
          imgEl.src = "data:image/png;base64," + imgBase64;
        } else {
          imgEl.src = "";
        }
      } catch (err) {
        outputEl.textContent = "âŒ Pyodide å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:\n" + err;
        imgEl.src = "";
        console.error(err);
      }
    }
  </script>
</body>
</html>
